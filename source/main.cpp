#include <nds.h>
#include <stdio.h>
#include <gl2d.h>

// Auto-generated GRIT files
#include "chell.h"
#include "gun.h"

// UVCOORD files (I wrote them myself)
#include "uvcoord_chell.h"
#include "uvcoord_gun.h"


glImage  Chell[CHELL_NUM_IMAGES];	
glImage  Gun[GUN_NUM_IMAGES];	

class Portal {
    public:
        int side; // 0 - left, 1 - right
        int pos[2];
};

int main() {
    /* sprites */
    videoSetMode(MODE_5_3D);
    consoleDemoInit();
    glScreen2D();

    vramSetBankA( VRAM_A_TEXTURE );
	vramSetBankB( VRAM_B_TEXTURE );

	vramSetBankF(VRAM_F_TEX_PALETTE);

    int Frame = 0;

    int playerPos[2] = {90, 140};
    int playerSize[2] = {19, 24};
    float playerSpeed = 0;
    int jumped = 0;
    int facing = 1; // 0 - left; 1 - right

    // glColor( RGB15(31, 31, 31) );

    int ChellTextureID = 
	glLoadSpriteSet( Chell,					// pointer to glImage array
					 CHELL_NUM_IMAGES, 		// Texture packer auto-generated #define
					 chell_texcoords,		// Texture packer auto-generated array
					 GL_RGB256,				// texture type for glTexImage2D() in videoGL.h 
					 TEXTURE_SIZE_128,		// sizeX for glTexImage2D() in videoGL.h
					 TEXTURE_SIZE_256,		// sizeY for glTexImage2D() in videoGL.h
					 GL_TEXTURE_WRAP_S|GL_TEXTURE_WRAP_T|TEXGEN_OFF|GL_TEXTURE_COLOR0_TRANSPARENT, // param for glTexImage2D() in videoGL.h
					 256,					// Length of the palette to use (256 colors)
					 (u16*)chellPal,		// Load our 256 color player palette
					 (u8*)chellBitmap	 	// image data generated by GRIT
				   );

    int GunTextureID = 
	glLoadSpriteSet( Gun,					// pointer to glImage array
					 GUN_NUM_IMAGES, 		// Texture packer auto-generated #define
					 gun_texcoords,		// Texture packer auto-generated array
					 GL_RGB256,				// texture type for glTexImage2D() in videoGL.h 
					 TEXTURE_SIZE_32,		// sizeX for glTexImage2D() in videoGL.h
					 TEXTURE_SIZE_16,		// sizeY for glTexImage2D() in videoGL.h
					 GL_TEXTURE_WRAP_S|GL_TEXTURE_WRAP_T|TEXGEN_OFF|GL_TEXTURE_COLOR0_TRANSPARENT, // param for glTexImage2D() in videoGL.h
					 256,					// Length of the palette to use (256 colors)
					 (u16*)gunPal,		// Load our 256 color gun palette
					 (u8*)gunBitmap	 	// image data generated by GRIT
				   );
    
    int ChellFrame = 0;
    int GunFrame = 0;

    int gunPosX = playerPos[0] + 7;
    int gunPosY = playerPos[1] + 8;
    float gunSpeed = 0;

    Portal port1;
    Portal port2;

    port1.pos[0] = 250;
    port1.pos[1] = 135;
    port1.side = 1;

    port2.pos[0] = 0;
    port2.pos[1] = 135;
    port2.side = 0;

    // int is255 = 0;

    /* game logic */
    while (1) {

        Frame++;

        scanKeys();

        glBegin2D();

        // glSetActiveTexture( ChellTextureID );

        if (facing == 0) {
            glSprite(playerPos[0], playerPos[1], GL_FLIP_H, &Chell[ChellFrame]);

            glSprite(gunPosX, gunPosY, GL_FLIP_H, &Gun[GunFrame]);
            gunPosX = playerPos[0] - playerSize[0] + 6;
        } else if (facing == 1) {
            glSprite(playerPos[0], playerPos[1], GL_FLIP_NONE, &Chell[ChellFrame]);

            glSprite(gunPosX, gunPosY, GL_FLIP_NONE, &Gun[GunFrame]);
            gunPosX = playerPos[0] + playerSize[0];
        }
        
        // glBoxFilled(playerPos[0], playerPos[1], playerPos[0] + playerSize[0], playerPos[1] + playerSize[1], RGB15(218, 255, 255)); // drawing player box
        // glBoxFilled(gunPosX, gunPosY, gunPosX + 12, gunPosY + 7, RGB15(221, 221, 221)); // drawing portal gun box

        // glBoxFilled(cubePosX, cubePosY, cubePosX + size, cubePosY + size, RGB15(221, 221, 221)); // drawing cube

        glBoxFilled(port1.pos[0], port1.pos[1], port1.pos[0] + 4, port1.pos[1] + 34, RGB15(128, 255, 255)); // blue portal
        glBoxFilled(port2.pos[0], port2.pos[1], port2.pos[0] + 4, port2.pos[1] + 34, RGB15(255, 109, 43)); // orange portal

        iprintf("\x1b[2J");
        iprintf("portal2ds - Made by GriShafir\n\nExample of Portal game in 2D \nmade for Nintendo DS.\n\n");

        iprintf("To move around, press Left and \nRight on the D-Pad.\nTo jump, press A.\n");
        iprintf("To create blue portal, press X.\nTo create orange portal, press \nY.");

        iprintf("\nPlayer's coordinates: \n%i, %i\n", playerPos[0], playerPos[1]);
        iprintf("\nBlue portal's coordinates: \n%i, %i\n", port1.pos[0], port1.pos[1]);
        iprintf("\nOrange portal's coordinates: \n%i, %i\n", port2.pos[0], port2.pos[1]);

        iprintf("\n\n\nv0.1.1-sprites");

        // iprintf("\nBlue portal's side: \n%i\n", port1.side);
        // iprintf("\nOrange portal's side: \n%i\n", port2.side);
        
        if ((KEY_A & keysDown()) & (jumped == 0)) { // basic jumping
            playerSpeed = -1.5;
            jumped = 1;
        } else if (KEY_LEFT & keysHeld()) { // basic walking
            playerPos[0] -= 2;

            facing = 0;
        } else if (KEY_RIGHT & keysHeld()) {
            playerPos[0] += 2;

            facing = 1;
        } 
        
        if (KEY_X & keysDown()) { // creating blue portal
            port1.pos[1] = playerPos[1] - 5;

            GunFrame = 1;

            if (facing == 1) {
                port1.pos[0] = 250;
                port1.side = 1;
            } else {
                port1.pos[0] = 0;
                port1.side = 0;

                glSprite(gunPosX, gunPosY, GL_FLIP_H, &Gun[GunFrame]);
            }

        } else if (KEY_Y & keysDown()) { // creating orange portal
            port2.pos[1] = playerPos[1] - 5;

            GunFrame = 2;

            if (facing == 1) {
                port2.pos[0] = 250;
                port2.side = 1;

                glSprite(gunPosX, gunPosY, GL_FLIP_H, &Gun[GunFrame]);
            } else {
                port2.pos[0] = 0;
                port2.side = 0;
            }
        }

        /* else if (KEY_R & keysDown() & weigh_cube.got == 0) { // getting cube
            weigh_cube.pos[1] = playerPosY;
            weigh_cube.speed = 54;
        } else if (KEY_R & keysDown() & weigh_cube.got == 1) { // placing cube
            weigh_cube.got = 0;
        } */
        if ((playerPos[1] > port1.pos[1]) & (playerPos[1] + playerSize[1] < port1.pos[1] + 34)) {
            if (port1.side == 0 & playerPos[0] < port1.pos[0]) {
                playerPos[0] = port2.pos[0] - 28;
                playerPos[1] = port2.pos[1] + 5;

                gunPosX = port2.pos[0] - 20;
                gunPosY = port2.pos[1] + 13;

            } else if (port1.side == 1 & playerPos[0] + playerSize[0] > port1.pos[0] + 4) {
                playerPos[0] = port2.pos[0] + 10;
                playerPos[1] = port2.pos[1] + 5;

                gunPosX = port2.pos[0] + 7;
                gunPosY = port2.pos[1] + 13;
            }
            
        } if ((playerPos[1] > port2.pos[1]) & (playerPos[1] + playerSize[1] < port2.pos[1] + 34)) {
            if (port2.side == 0 & playerPos[0] < port2.pos[0]) {
                playerPos[0] = port1.pos[0] - 10;
                playerPos[1] = port1.pos[1] + 5;

                gunPosX = port1.pos[0] - 10;
                gunPosY = port1.pos[1] + 13;

            } else if (port2.side == 1 & playerPos[0] + playerSize[0] > port2.pos[0] + 4) {
                playerPos[0] = port1.pos[0] + 10;
                playerPos[1] = port1.pos[1] + 5;

                gunPosX = port1.pos[0] + 7;
                gunPosY = port1.pos[1] + 13;
            }
        }

         if (playerPos[0] > 237) { // no going through the walls
            playerPos[0] = 237;
        } else if (playerPos[0] < 0) {
            playerPos[0] = 0;
        } 

        playerPos[1] += playerSpeed;
        gunPosX += gunSpeed;
        gunPosY += playerSpeed;
        // cubePosX = cubeSpeed;

        if (playerPos[1] < 140) { // basic falling
            playerSpeed += 0.125;
        } else {
            playerPos[1] = 140;
            jumped = 0;
            gunPosY = playerPos[1] + 8;
        }

        glEnd2D();
        glFlush(0);
        
        swiWaitForVBlank();
    }
}
