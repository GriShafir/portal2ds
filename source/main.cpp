/*------------------------------------------------------------------------------ 
portal2ds by GriShafir

Suppositioned controls:
UP + X = Make blue portal up
DOWN + X = Make blue portal down
UP + Y = Make orange portal up
DOWN + Y = Make orange portal down

B = press the button (if one is near)
R = Grab an object (for example, cube and turret)
DOWN = Crouch
------------------------------------------------------------------------------ */

#include <nds.h>
#include <stdio.h>
#include <gl2d.h>

// Auto-generated GRIT files
#include "chell.h"
#include "gun.h"
#include "blueportal.h"
#include "orangeportal.h"
#include "weighcube.h"
#include "floorbutton.h"
#include "door.h"
#include "aerialfaithplate.h"
#include "tile.h"

// UVCOORD files (I wrote them myself)
#include "uvcoord_chell.h"
#include "uvcoord_gun.h"
#include "uvcoord_blportal.h"
#include "uvcoord_orportal.h"
#include "uvcoord_flbutton.h"
#include "uvcoord_door.h"
#include "uvcoord_afplate.h"


glImage  Chell[CHELL_NUM_IMAGES];	
glImage  Gun[GUN_NUM_IMAGES];	 

glImage  BlPortal[BLPORTAL_NUM_IMAGES];
glImage  OrPortal[ORPORTAL_NUM_IMAGES];

glImage  WeighCube[1];
glImage  FlButton[FLBUTTON_NUM_IMAGES];
glImage  Door[DOOR_NUM_IMAGES];
glImage  AFPlate[AFPLATE_NUM_IMAGES];

glImage  Tile[1];

class Portal {
    public:
        int side; // 0 - left, 1 - right
        int pos[2];
};

class Cube {
    public: 
        int type; // 0 - weighted, 1 - companion
        int pos[2];

        float speed;

        int textureID;
};

class Platform {
    public:
        int pos[2];
        int size[2];
};

int player_pos[2] = {0, 0};
int world_size[2] = {384, 288};
int world_move = 0;

void DrawBG( glImage *images );

int main() {
    /* sprites */
    videoSetMode(MODE_5_3D);
    consoleDemoInit();
    glScreen2D();

    vramSetBankA( VRAM_A_TEXTURE );
	vramSetBankB( VRAM_B_TEXTURE );

	vramSetBankF(VRAM_F_TEX_PALETTE);

    int Frame = 0;

    int playerPos[2] = {115, 140};
    int playerSize[2] = {19, 24};
    float playerHorSpeed = 0;
    float playerSpeed = 0;
    int jumped = 0;
    int facing = 1; // 0 - left; 1 - right
    /* int hasGun = 1; // 0 - player doesn't have, 
                        // 1 - player has*/
    int isHolding = 0; // 0 - no, 1 - yes

    int ChellTextureID = 
	glLoadSpriteSet( Chell,					// pointer to glImage array
					 CHELL_NUM_IMAGES, 		// Texture packer auto-generated #define
					 chell_texcoords,		// Texture packer auto-generated array
					 GL_RGB256,				// texture type for glTexImage2D() in videoGL.h 
					 TEXTURE_SIZE_128,		// sizeX for glTexImage2D() in videoGL.h
					 TEXTURE_SIZE_256,		// sizeY for glTexImage2D() in videoGL.h
					 GL_TEXTURE_WRAP_S|GL_TEXTURE_WRAP_T|TEXGEN_OFF|GL_TEXTURE_COLOR0_TRANSPARENT, // param for glTexImage2D() in videoGL.h
					 256,					// Length of the palette to use (256 colors)
					 (u16*)chellPal,		// Load our 256 color player palette
					 (u8*)chellBitmap	 	// image data generated by GRIT
				   );

    int GunTextureID = 
	glLoadSpriteSet( Gun,					// pointer to glImage array
					 GUN_NUM_IMAGES, 		// Texture packer auto-generated #define
					 gun_texcoords,		    // Texture packer auto-generated array
					 GL_RGB256,				// texture type for glTexImage2D() in videoGL.h 
					 TEXTURE_SIZE_32,		// sizeX for glTexImage2D() in videoGL.h
					 TEXTURE_SIZE_16,		// sizeY for glTexImage2D() in videoGL.h
					 GL_TEXTURE_WRAP_S|GL_TEXTURE_WRAP_T|TEXGEN_OFF|GL_TEXTURE_COLOR0_TRANSPARENT, // param for glTexImage2D() in videoGL.h
					 256,					// Length of the palette to use (256 colors)
					 (u16*)gunPal,		    // Load our 256 color gun palette
					 (u8*)gunBitmap	 	    // image data generated by GRIT
				   );
    int ChellFrame = 5;
    int GunFrame = 0;
    int PortalFrame = 0;
    int DoorFrame = 0;
    int AFPlateFrame = 0;

    int gunPosX = playerPos[0] + 7;
    int gunPosY = playerPos[1] + 8;

    Portal port1;
    Portal port2;

    int BlPortalTextureID = 
	glLoadSpriteSet( BlPortal,					// pointer to glImage array
					 BLPORTAL_NUM_IMAGES, 		// Texture packer auto-generated #define
					 blportal_texcoords,		// Texture packer auto-generated array
					 GL_RGB256,				    // texture type for glTexImage2D() in videoGL.h 
					 TEXTURE_SIZE_64,		    // sizeX for glTexImage2D() in videoGL.h
					 TEXTURE_SIZE_64,		    // sizeY for glTexImage2D() in videoGL.h
					 GL_TEXTURE_WRAP_S|GL_TEXTURE_WRAP_T|TEXGEN_OFF|GL_TEXTURE_COLOR0_TRANSPARENT, // param for glTexImage2D() in videoGL.h
					 256,					    // Length of the palette to use (256 colors)
					 (u16*)blueportalPal,		// Load our 256 color portal palette
					 (u8*)blueportalBitmap	 	// image data generated by GRIT
				   );

    port1.pos[0] = -500;
    port1.pos[1] = -500;
    port1.side = 1;

    int port1_pos[2] = {-500, -500};

    int OrPortalTextureID = 
	glLoadSpriteSet( OrPortal,					    // pointer to glImage array
					 ORPORTAL_NUM_IMAGES, 		    // Texture packer auto-generated #define
					 orportal_texcoords,		    // Texture packer auto-generated array
					 GL_RGB256,				        // texture type for glTexImage2D() in videoGL.h 
					 TEXTURE_SIZE_64,		        // sizeX for glTexImage2D() in videoGL.h
					 TEXTURE_SIZE_64,		        // sizeY for glTexImage2D() in videoGL.h
					 GL_TEXTURE_WRAP_S|GL_TEXTURE_WRAP_T|TEXGEN_OFF|GL_TEXTURE_COLOR0_TRANSPARENT, // param for glTexImage2D() in videoGL.h
					 256,					        // Length of the palette to use (256 colors)
					 (u16*)orangeportalPal,		    // Load our 256 color portal palette
					 (u8*)orangeportalBitmap	 	// image data generated by GRIT
				   );

    port2.pos[0] = -500;
    port2.pos[1] = -500;
    port2.side = 0;

    int port2_pos[2] = {-500, -500};

    Cube cube;
    int WeighCubeTextureID = 
	glLoadTileSet( WeighCube,			        // pointer to glImage array
				     11,                        // sprite width
					 11,					    // sprite height
					 16,					    // bitmap width
					 16,					    // bitmap height
					 GL_RGB256,				    // texture type for glTexImage2D() in videoGL.h 
					 TEXTURE_SIZE_16,		    // sizeX for glTexImage2D() in videoGL.h
					 TEXTURE_SIZE_16,		    // sizeY for glTexImage2D() in videoGL.h
					 GL_TEXTURE_WRAP_S|GL_TEXTURE_WRAP_T|TEXGEN_OFF|GL_TEXTURE_COLOR0_TRANSPARENT, // param for glTexImage2D() in videoGL.h
					 256,					    // Length of the palette to use (256 colors)
					 (u16*)weighcubePal,		// Load our 256 color cube palette
					 (u8*)weighcubeBitmap	 	// image data generated by GRIT
				   );


    cube.pos[0] = 140;
    cube.pos[1] = 53;

    cube.speed = 0;
    cube.type = 0;
    cube.textureID = WeighCubeTextureID;

    int FlButtonTextureID = 
	glLoadSpriteSet( FlButton,					// pointer to glImage array
					 FLBUTTON_NUM_IMAGES, 		// Texture packer auto-generated #define
					 flbutton_texcoords,		// Texture packer auto-generated array
					 GL_RGB256,				    // texture type for glTexImage2D() in videoGL.h 
					 TEXTURE_SIZE_32,		    // sizeX for glTexImage2D() in videoGL.h
					 TEXTURE_SIZE_16,		    // sizeY for glTexImage2D() in videoGL.h
					 GL_TEXTURE_WRAP_S|GL_TEXTURE_WRAP_T|TEXGEN_OFF|GL_TEXTURE_COLOR0_TRANSPARENT, // param for glTexImage2D() in videoGL.h
					 256,					    // Length of the palette to use (256 colors)
					 (u16*)floorbuttonPal,		// Load our 256 color portal palette
					 (u8*)floorbuttonBitmap	 	// image data generated by GRIT
				   );

    int isActive = 0;
    int flButtonPos[2] = {50, 160};

    int DoorTextureID = 
	glLoadSpriteSet( Door,					// pointer to glImage array
					 DOOR_NUM_IMAGES, 		// Texture packer auto-generated #define
					 door_texcoords,		// Texture packer auto-generated array
					 GL_RGB256,				// texture type for glTexImage2D() in videoGL.h 
					 TEXTURE_SIZE_128,		// sizeX for glTexImage2D() in videoGL.h
					 TEXTURE_SIZE_128,		// sizeY for glTexImage2D() in videoGL.h
					 GL_TEXTURE_WRAP_S|GL_TEXTURE_WRAP_T|TEXGEN_OFF|GL_TEXTURE_COLOR0_TRANSPARENT, // param for glTexImage2D() in videoGL.h
					 256,					// Length of the palette to use (256 colors)
					 (u16*)doorPal,		    // Load our 256 color portal palette
					 (u8*)doorBitmap	 	// image data generated by GRIT
				   );

    int doorPos[2] = {180, 137};

    int AFPlateTextureID = 
	glLoadSpriteSet( AFPlate,					// pointer to glImage array
					 AFPLATE_NUM_IMAGES, 		// Texture packer auto-generated #define
					 afplate_texcoords,		    // Texture packer auto-generated array
					 GL_RGB256,				    // texture type for glTexImage2D() in videoGL.h 
					 TEXTURE_SIZE_64,		    // sizeX for glTexImage2D() in videoGL.h
					 TEXTURE_SIZE_128,		    // sizeY for glTexImage2D() in videoGL.h
					 GL_TEXTURE_WRAP_S|GL_TEXTURE_WRAP_T|TEXGEN_OFF|GL_TEXTURE_COLOR0_TRANSPARENT, // param for glTexImage2D() in videoGL.h
					 256,					    // Length of the palette to use (256 colors)
					 (u16*)aerialfaithplatePal, // Load our 256 color portal palette
					 (u8*)aerialfaithplateBitmap// image data generated by GRIT
				   );

    int AFPlatePos[2] = {130, 152};
    int plateJumped = 0;

    int TileTextureID = 
	glLoadTileSet( Tile,			        // pointer to glImage array
				     16,                        // sprite width
					 16,					    // sprite height
					 16,					    // bitmap width
					 16,					    // bitmap height
					 GL_RGB256,				    // texture type for glTexImage2D() in videoGL.h 
					 TEXTURE_SIZE_16,		    // sizeX for glTexImage2D() in videoGL.h
					 TEXTURE_SIZE_16,		    // sizeY for glTexImage2D() in videoGL.h
					 GL_TEXTURE_WRAP_S|GL_TEXTURE_WRAP_T|TEXGEN_OFF|GL_TEXTURE_COLOR0_TRANSPARENT, // param for glTexImage2D() in videoGL.h
					 256,					    // Length of the palette to use (256 colors)
					 (u16*)tilePal,		// Load our 256 color cube palette
					 (u8*)tileBitmap	 	// image data generated by GRIT
				   );

    /* game logic */
    while (1) {

        Frame++;

        scanKeys();

        glBegin2D();

        // DrawBG(Tile);

        glSprite(flButtonPos[0], flButtonPos[1], GL_FLIP_NONE, &FlButton[isActive]);
        glSprite(doorPos[0], doorPos[1], GL_FLIP_NONE, &Door[DoorFrame]);
        glSprite(cube.pos[0], cube.pos[1], GL_FLIP_NONE, &WeighCube[0]);
        glSprite(AFPlatePos[0], AFPlatePos[1], GL_FLIP_NONE, &AFPlate[AFPlateFrame]);

        glSprite(port1.pos[0], port1.pos[1], GL_FLIP_H, &BlPortal[PortalFrame]);
        glSprite(port2.pos[0], port2.pos[1], GL_FLIP_NONE, &OrPortal[PortalFrame]);

        if (facing == 0) {
            glSprite(playerPos[0], playerPos[1], GL_FLIP_H, &Chell[ChellFrame]);

            // glSprite(gunPosX, gunPosY, GL_FLIP_H, &Gun[GunFrame]);

            gunPosX = playerPos[0] + 9;
            gunPosY = playerPos[1] + 13;
        } else if (facing == 1) {
            glSprite(playerPos[0], playerPos[1], GL_FLIP_NONE, &Chell[ChellFrame]);

            // glSprite(gunPosX, gunPosY, GL_FLIP_NONE, &Gun[GunFrame]);
        }
        
        // glBoxFilled(playerPos[0], playerPos[1], playerPos[0] + playerSize[0], playerPos[1] + playerSize[1], RGB15(218, 255, 255)); // drawing player box
        // glBoxFilled(gunPosX, gunPosY, gunPosX + 12, gunPosY + 7, RGB15(221, 221, 221)); // drawing portal gun box

        // glBoxFilled(cubePosX, cubePosY, cubePosX + size, cubePosY + size, RGB15(221, 221, 221)); // drawing cube

        // glBoxFilled(port1.pos[0], port1.pos[1], port1.pos[0] + 4, port1.pos[1] + 34, RGB15(44, 68, 254)); // blue portal
        // glBoxFilled(port2.pos[0], port2.pos[1], port2.pos[0] + 4, port2.pos[1] + 34, RGB15(255, 137, 44)); // orange portal

        // glBoxFilled(plat.pos[0], plat.pos[1], plat.pos[0] + plat.size[0], plat.pos[1] + plat.size[1], RGB15(255, 255, 255));

        switch(ChellFrame) {
            case 6:
            gunPosY = playerPos[1] + 13;
                switch(facing) {
                    case 1:
                    gunPosX = playerPos[0] + 12;
                    break;
                    case 0:
                    gunPosX = playerPos[0] + 8;
                    break;
                }
                break;
            case 7:
            gunPosY = playerPos[1] + 13;
                switch(facing) {
                    case 1:
                    gunPosX = playerPos[0] + 9;
                    break;
                }
                break;
            case 8:
            gunPosY = playerPos[1] + 11;
                switch(facing) {
                    case 1:
                    gunPosX = playerPos[0] + 18;
                    break;
                }
                break;
            case 9:
            gunPosY = playerPos[1] + 10;
                switch(facing) {
                    case 1:
                    gunPosX = playerPos[0] + 15;
                    break;
                }
                break;
            default:
            gunPosY = playerPos[1] + 12;
                switch(facing) {
                    case 1:
                    gunPosX = playerPos[0] + 7;
                    break;
                }
                break;
        }

        iprintf("\x1b[2J");
        iprintf("portal2ds v0.2.2-ge - Made by \nGriShafir\n\nA Portal game \nin 2D made for Nintendo DS.\n\n"); // desc

        iprintf("To move around, press Left and \nRight on the D-Pad.\n");               // controls
        iprintf("To jump, press A.\nTo grab an object, press B near that object.\n");
        iprintf("To create blue portal, press X.\nTo create orange portal, press \nY.");

        iprintf("\nPlayer's coordinates: \n%i, %i\n", player_pos[0], playerPos[1]);        // coords
        iprintf("\nBlue portal's coordinates: \n%i, %i\n", port1.pos[0], port1.pos[1]);
        iprintf("\nOrange portal's coordinates: \n%i, %i\n", port2.pos[0], port2.pos[1]);
        
        // iprintf("%i, %i", (playerPos[0] - cubePos[0]), (cubePos[0] - playerPos[0]));
        
        if ((KEY_A & keysDown()) & (jumped == 0)) { // basic jumping
            playerSpeed = -1.75;
            jumped = 1;
        } else if (KEY_LEFT & keysHeld()) { // basic walking
            world_move = 2;
            facing = 0;

            if ((Frame & 5) == 0) {
                ChellFrame++;

                if (ChellFrame > 8) ChellFrame = 6;
            }
        } else if (KEY_RIGHT & keysHeld()) {
            world_move = -2;
            facing = 1;

            if ((Frame & 5) == 0) {
                ChellFrame++;

                if (ChellFrame > 8) ChellFrame = 6;
            }
        } else if (KEY_UP & keysHeld()) {
            ChellFrame = 10;
            world_move = 0;
        } else {
            ChellFrame = 5;
            world_move = 0;
        } 
        
        if ((KEY_X & keysDown()) && (isHolding == 0)) { // creating blue portal
            if (facing == port2.side) {
                if (!(playerPos[1] - 5 >= port2.pos[1] && playerPos[1] - 5 <= port2.pos[1] + 29) && 
                    !(playerPos[1] + 24 <= port2.pos[1] + 29 && playerPos[1] + 24 >= port2.pos[1])) {

                    port1.pos[1] = playerPos[1] - 5;
                    port1_pos[1] = playerPos[1] - 5;

                    GunFrame = 1;

                    switch(facing) {
                        case 1:
                            port1.pos[0] = world_size[0] / 2 - 5;
                            port1_pos[0] = world_size[0] / 2 - 5;
                            port1.side = 1;
                            break;
                        default:
                            port1.pos[0] = -(world_size[0]) / 2;
                            port1_pos[0] = -(world_size[0]) / 2;
                            port1.side = 0;
                            break;
                    }
                }
            }
            else {
                port1.pos[1] = playerPos[1] - 5;

                    GunFrame = 1;

                    switch(facing) {
                        case 1:
                            port1.pos[0] = 251;
                            port1_pos[0] = 251;
                            port1.side = 1;
                            break;
                        default:
                            port1.pos[0] = 0;
                            port1_pos[0] = 0;
                            port1.side = 0;
                            break;
                    }
            }
        } else if ((KEY_Y & keysDown()) && (isHolding == 0)) { // creating orange portal 
            if (facing == port1.side) {
                if (!(playerPos[1] - 5 >= port1.pos[1] && playerPos[1] - 5 <= port1.pos[1] + 29) && 
                    !(playerPos[1] + 24 <= port1.pos[1] + 29 && playerPos[1] + 24 >= port1.pos[1])) {

                    port2.pos[1] = playerPos[1] - 5;

                    GunFrame = 1;

                    switch(facing) {
                        case 1:
                            port2.pos[0] = world_size[0] / 2 - 5;
                            port2_pos[0] = world_size[0] / 2 - 5;
                            port2.side = 1;
                            break;
                        default:
                            port2.pos[0] = -(world_size[0]) / 2;
                            port2_pos[0] = -(world_size[0]) / 2;
                            port2.side = 0;
                            break;
                    }
                }
            }
            else {
                port2.pos[1] = playerPos[1] - 5;

                    GunFrame = 1;

                    switch(facing) {
                        case 1:
                            port2.pos[0] = 251;
                            port2_pos[0] = 251;
                            port2.side = 1;
                            break;
                        default:
                            port2.pos[0] = 0;
                            port2_pos[0] = 0;
                            port2.side = 0;
                            break;
                    }
            }
        }

        if ((KEY_B & keysDown()) // holding a cube
        && ((cube.pos[0] - playerPos[0] < 30) && (cube.pos[0] - playerPos[0] > -30)) 
        && ((playerPos[0] - cube.pos[0] < 30) && (playerPos[0] - cube.pos[0] > -30))) {
            switch(isHolding) {
                case 0:
                    isHolding = 1;
                    break;
                default:
                    isHolding = 0;
                    break;
            }
        }

        if (isHolding == 1) {
            cube.pos[1] = playerPos[1] + 7;
            cube.speed = 0;
            switch(facing) {
                case 1:
                    cube.pos[0] = playerPos[0] + 25;
                    break;
                default:
                    cube.pos[0] = playerPos[0] - 15;
                    break;
            }
        }

        if ((cube.pos[0] > flButtonPos[0]) && (cube.pos[0] + 11 < flButtonPos[0] + 25) 
        && (cube.pos[1] + 11 > flButtonPos[1] - 1)) {
            isActive = 1;
        } else {
            isActive = 0;
        }

        switch(isActive) {
            case 1:
                if (DoorFrame < 5) {
                    if ((Frame & 7) == 0) {
                        DoorFrame++;
                    }
                } else {
                    if ((Frame & 3) == 0) {
                        DoorFrame++;
                    }
                    if (DoorFrame > 9) DoorFrame = 9;
                }
                
                cube.pos[1] = flButtonPos[1] - 10;
                cube.speed = 0;
                break;
            default:
                if ((Frame & 2) == 0) {
                    DoorFrame--;
                    
                    if (DoorFrame < 0) DoorFrame = 0;
                }
        }

        if ((DoorFrame == 9) && (KEY_UP & keysDown()) 
        && ((playerPos[0] > doorPos[0]) && (playerPos[0] + playerSize[0] < doorPos[0] + 29) && (playerPos[1] > doorPos[1]))) {
            ChellFrame = 5;
            break;
        }

        /* if ((Frame & 5) == 0) {
            PortalFrame++;

            if (PortalFrame > 16) {
                PortalFrame = 0;
            } 
        } */

        if ((playerPos[0] > AFPlatePos[0] + 3) && (playerPos[0] + playerSize[0] < AFPlatePos[0] + 32) // jumping on an aerial faith plate
        && (plateJumped == 0) && (playerPos[1] + 24 == AFPlatePos[1] + 12)) {
            plateJumped = 1;

            playerHorSpeed = 0;
            playerSpeed = -4;
        }

        switch(plateJumped) {
            case 1:
                if ((Frame & 1) == 0) {
                    AFPlateFrame++;

                    if (AFPlateFrame > 9) {
                        AFPlateFrame = 9;

                        plateJumped = 0;
                    }
                }
                break;
            default:
                if ((Frame & 7) == 0) {
                    AFPlateFrame--;

                    if (AFPlateFrame < 0) AFPlateFrame = 0;
                }
                break;
        }

        if ((playerPos[1] > port1.pos[1]) & (playerPos[1] + playerSize[1] < port1.pos[1] + 32)) { // teleport from blue
            if ((port1.side == 0) && (playerPos[0] == port1.pos[0]) && (port2_pos[0] != -500)) {
                player_pos[0] = port2.pos[0];
                player_pos[1] = port2.pos[1] + 5;

                playerPos[0] = port2.pos[0];
                playerPos[1] = port2.pos[1] + 5;

                gunPosX = port2.pos[0] - 20;
                gunPosY = port2.pos[1] + 13;

            } else if ((port1.side == 1) && (port1.pos[0] - playerPos[0] == playerSize[0] + 5) 
            && (port2_pos[0] != -500)) {
                player_pos[0] = port2.pos[0] + 10;
                player_pos[1] = port2.pos[1] + 5;
                world_move = (port1_pos[0] - port2_pos[0]) * (port1_pos[0] * .05);

                playerPos[0] = port2.pos[0] + 10;
                playerPos[1] = port2.pos[1] + 5;

                gunPosX = port2.pos[0] + 7;
                gunPosY = port2.pos[1] + 13;
            }

        } if ((playerPos[1] > port2.pos[1]) & (playerPos[1] + playerSize[1] < port2.pos[1] + 32)) { // teleport from orange
            if ((port2.side == 0) && (playerPos[0] == port2.pos[0] && (port1_pos[0] != -500))) {
                player_pos[0] = port1.pos[0] - 10;
                player_pos[1] = port1.pos[1] + 5;
                world_move = (port1_pos[0] - port2_pos[0]) * (port2_pos[0] * .05);

                playerPos[0] = port1.pos[0] - 10;
                playerPos[1] = port1.pos[1] + 5;

                gunPosX = port1.pos[0] - 10;
                gunPosY = port1.pos[1] + 13;

            } else if ((port2.side == 1) && (playerPos[0] + playerSize[0] > port2.pos[0] + 4) 
            && (port1_pos[0] != -500)) {
                playerPos[0] = port1.pos[0] + 10;
                playerPos[1] = port1.pos[1] + 5;

                gunPosX = port1.pos[0] + 7;
                gunPosY = port1.pos[1] + 13;
            }
        }

        if (playerPos[0] > 237) { // no going through the walls
            playerPos[0] = 237;
            player_pos[0] = (world_size[0] - (256 - 237)) * 1.184573;
        } else if (playerPos[0] < 0) {
            playerPos[0] = 0;
            player_pos[0] = -((world_size[0] - (256 - 237)) * 1.174573);
        } 

        playerPos[1] += playerSpeed;
        world_move += playerHorSpeed;
        cube.pos[1] += cube.speed;
        // gunPosY += playerSpeed;

        

        if (playerPos[1] < 140) { // basic falling
            playerSpeed += 0.125;
            ChellFrame = 9;
        } else {
            playerPos[1] = 140;
            jumped = 0;
            playerSpeed = 0;
            playerHorSpeed = 0;
        }

        if (cube.pos[1] < 153) {
            cube.speed += 0.125;
        } else {
            cube.speed = 0;
            isHolding = 0;
        }

        /* if (cube.pos[0] < 0) {
            cube.pos[0] = 0;
        } else if (cube.pos[0] > 245) {
            cube.pos[0] = 245;
        } */

        player_pos[0] -= world_move;

        if ((player_pos[0] < -(world_size[0] / 2) - 115) || (player_pos[0] > world_size[0] / 2 + 115)) {
            playerPos[0] -= world_move;
        } else {
            doorPos[0] += world_move;
            AFPlatePos[0] += world_move;
            flButtonPos[0] += world_move;
            port1.pos[0] += world_move;
            port2.pos[0] += world_move;
            cube.pos[0] += world_move;
            playerPos[0] = 115;
        }

        glEnd2D();
        glFlush(0);

        if (KEY_START & keysDown()) break;
        
        swiWaitForVBlank();
    }
}

void DrawBG( glImage *images )
{
	int x,y;
	
	for( y = 0; y < 16; y++ )
	{
		for( x = 0; x < 16; x++ )
		{
			glSprite(x * 16, y * 16, GL_FLIP_NONE, &images[0]);
		}
	}

    if ((player_pos[0] > -(world_size[0] / 2) - 115) || (player_pos[0] < world_size[0] / 2 + 115)) {
        x += world_move;
    }
}